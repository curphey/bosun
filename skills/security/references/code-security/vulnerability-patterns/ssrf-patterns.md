<!--
Copyright (c) 2025 Crash Override Inc. - https://crashoverride.com

SPDX-License-Identifier: GPL-3.0
-->

# Server-Side Request Forgery (SSRF) Patterns

## SSRF Overview (CWE-918)

### Description
SSRF occurs when an attacker can induce the server-side application to make HTTP requests to an arbitrary domain. This can be used to:
- Access internal services behind firewalls
- Read cloud metadata (AWS, GCP, Azure)
- Port scan internal networks
- Access localhost-only services
- Bypass access controls

---

## Python SSRF Patterns

### Dangerous Patterns

```python
# VULNERABLE - requests with user-controlled URL
import requests

url = request.args.get('url')
response = requests.get(url)  # SSRF

# VULNERABLE - urllib
import urllib.request
data = urllib.request.urlopen(user_url).read()

# VULNERABLE - httpx
import httpx
response = httpx.get(user_provided_url)

# VULNERABLE - aiohttp
import aiohttp
async with aiohttp.ClientSession() as session:
    async with session.get(user_url) as response:
        data = await response.text()

# VULNERABLE - webhook/callback URL
webhook_url = request.json.get('callback_url')
requests.post(webhook_url, json=result)

# VULNERABLE - image/file fetching
image_url = request.form.get('avatar_url')
response = requests.get(image_url)
save_image(response.content)

# VULNERABLE - URL in redirect
redirect_url = request.args.get('next')
return redirect(redirect_url)  # Open redirect, can chain to SSRF
```

### Safe Patterns

```python
# SECURE - URL validation with allowlist
from urllib.parse import urlparse

ALLOWED_HOSTS = ['api.trusted.com', 'cdn.trusted.com']

def validate_url(url):
    parsed = urlparse(url)
    if parsed.hostname not in ALLOWED_HOSTS:
        raise ValueError("URL not in allowlist")
    if parsed.scheme not in ('http', 'https'):
        raise ValueError("Invalid scheme")
    return url

url = validate_url(request.args.get('url'))
response = requests.get(url)

# SECURE - block internal IPs
import ipaddress
import socket

def is_internal_ip(hostname):
    try:
        ip = ipaddress.ip_address(socket.gethostbyname(hostname))
        return ip.is_private or ip.is_loopback or ip.is_reserved
    except:
        return True  # Block if resolution fails

def safe_request(url):
    parsed = urlparse(url)
    if is_internal_ip(parsed.hostname):
        raise ValueError("Internal IP not allowed")
    return requests.get(url, allow_redirects=False)

# SECURE - use SSRF protection library
from ssrf_guard import SSRFGuard
guard = SSRFGuard()
response = guard.get(user_url)
```

---

## JavaScript/Node.js SSRF Patterns

### Dangerous Patterns

```javascript
// VULNERABLE - fetch with user URL
const response = await fetch(req.body.url);

// VULNERABLE - axios
const response = await axios.get(req.query.url);

// VULNERABLE - request/got/node-fetch
const got = require('got');
const response = await got(userProvidedUrl);

// VULNERABLE - image proxy
app.get('/proxy', async (req, res) => {
  const imageUrl = req.query.url;
  const response = await fetch(imageUrl);  // SSRF
  res.send(await response.buffer());
});

// VULNERABLE - webhook notification
await fetch(user.webhookUrl, {
  method: 'POST',
  body: JSON.stringify(event)
});
```

### Safe Patterns

```javascript
// SECURE - URL validation
const { URL } = require('url');

const ALLOWED_HOSTS = new Set(['api.example.com', 'cdn.example.com']);

function validateUrl(urlString) {
  const url = new URL(urlString);

  if (!ALLOWED_HOSTS.has(url.hostname)) {
    throw new Error('Host not allowed');
  }

  if (!['http:', 'https:'].includes(url.protocol)) {
    throw new Error('Invalid protocol');
  }

  return url.href;
}

// SECURE - block private IPs
const { isPrivate } = require('ip');
const dns = require('dns').promises;

async function isInternalUrl(urlString) {
  const url = new URL(urlString);
  const addresses = await dns.resolve(url.hostname);
  return addresses.some(addr => isPrivate(addr));
}

// SECURE - disable redirects
const response = await fetch(url, { redirect: 'error' });
```

---

## Java SSRF Patterns

### Dangerous Patterns

```java
// VULNERABLE - HttpURLConnection
String url = request.getParameter("url");
URL urlObj = new URL(url);
HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();
InputStream is = conn.getInputStream();

// VULNERABLE - Apache HttpClient
String url = request.getParameter("target");
HttpGet httpGet = new HttpGet(url);
CloseableHttpResponse response = httpClient.execute(httpGet);

// VULNERABLE - OkHttp
String url = request.getParameter("endpoint");
Request req = new Request.Builder().url(url).build();
Response response = client.newCall(req).execute();

// VULNERABLE - RestTemplate
String url = request.getParameter("service");
ResponseEntity<String> response = restTemplate.getForEntity(url, String.class);

// VULNERABLE - WebClient
String url = request.getParameter("api");
Mono<String> result = webClient.get().uri(url).retrieve().bodyToMono(String.class);
```

### Safe Patterns

```java
// SECURE - URL validation
import java.net.URL;
import java.util.Set;

private static final Set<String> ALLOWED_HOSTS = Set.of(
    "api.trusted.com",
    "cdn.trusted.com"
);

public boolean isValidUrl(String urlString) throws MalformedURLException {
    URL url = new URL(urlString);

    if (!ALLOWED_HOSTS.contains(url.getHost())) {
        return false;
    }

    if (!url.getProtocol().equals("https")) {
        return false;
    }

    return true;
}

// SECURE - block internal IPs
import java.net.InetAddress;

public boolean isInternalIp(String hostname) {
    try {
        InetAddress addr = InetAddress.getByName(hostname);
        return addr.isLoopbackAddress() ||
               addr.isSiteLocalAddress() ||
               addr.isLinkLocalAddress();
    } catch (UnknownHostException e) {
        return true;  // Block if can't resolve
    }
}
```

---

## Go SSRF Patterns

### Dangerous Patterns

```go
// VULNERABLE - http.Get with user URL
url := r.URL.Query().Get("url")
resp, err := http.Get(url)  // SSRF

// VULNERABLE - custom client
url := r.FormValue("target")
req, _ := http.NewRequest("GET", url, nil)
resp, err := client.Do(req)

// VULNERABLE - following redirects
resp, err := http.Get(userUrl)  // Follows redirects by default
```

### Safe Patterns

```go
// SECURE - URL validation
import (
    "net"
    "net/url"
)

var allowedHosts = map[string]bool{
    "api.trusted.com": true,
    "cdn.trusted.com": true,
}

func validateURL(rawURL string) error {
    parsed, err := url.Parse(rawURL)
    if err != nil {
        return err
    }

    if !allowedHosts[parsed.Host] {
        return errors.New("host not allowed")
    }

    if parsed.Scheme != "https" {
        return errors.New("only HTTPS allowed")
    }

    return nil
}

// SECURE - block internal IPs
func isInternalIP(host string) bool {
    ips, err := net.LookupIP(host)
    if err != nil {
        return true  // Block on error
    }

    for _, ip := range ips {
        if ip.IsLoopback() || ip.IsPrivate() || ip.IsLinkLocalUnicast() {
            return true
        }
    }
    return false
}

// SECURE - disable redirects
client := &http.Client{
    CheckRedirect: func(req *http.Request, via []*http.Request) error {
        return http.ErrUseLastResponse
    },
}
```

---

## Cloud Metadata Endpoints

### Critical Internal URLs to Block

| Cloud | Metadata URL | Risk |
|-------|--------------|------|
| AWS | `http://169.254.169.254/latest/meta-data/` | Instance credentials, IAM role tokens |
| GCP | `http://metadata.google.internal/` | Service account tokens |
| Azure | `http://169.254.169.254/metadata/` | Managed identity tokens |
| DigitalOcean | `http://169.254.169.254/metadata/` | Droplet metadata |
| Oracle Cloud | `http://169.254.169.254/opc/v1/` | Instance metadata |

### AWS-Specific Attacks
```
# Get IAM credentials
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/meta-data/iam/security-credentials/[role-name]

# IMDSv2 bypass attempts
http://[::ffff:169.254.169.254]/
http://169.254.169.254.xip.io/
http://0xa9fea9fe/  # Decimal IP
```

---

## Detection Indicators

### URL Parameters to Monitor
- `url`, `uri`, `link`, `src`, `href`
- `callback`, `webhook`, `redirect`, `next`, `return`
- `target`, `dest`, `destination`, `endpoint`
- `proxy`, `fetch`, `load`, `resource`
- `avatar`, `image`, `file`, `import`

### Bypass Techniques to Detect
- Decimal/octal IP: `http://2130706433/` (127.0.0.1)
- IPv6: `http://[::1]/`, `http://[::ffff:127.0.0.1]/`
- DNS rebinding: attacker-controlled DNS
- URL encoding: `http://127.0.0.1%00@evil.com/`
- Redirects: External URL that redirects to internal

### Defense Checklist
1. Validate URL against allowlist of hosts
2. Resolve DNS and check IP is not private/internal
3. Disable or limit HTTP redirects
4. Block access to metadata IPs (169.254.x.x)
5. Use egress firewall rules
6. Implement network segmentation

---

## Detection Patterns

### Python SSRF

#### Requests with User URL
**Pattern**: `requests\.(get|post|put|delete|head|patch)\s*\(\s*(request\.(args|form|json)|user_url|url_param)`
**Type**: regex
**Severity**: critical
**Languages**: [python]
- Python requests with user-controlled URL
- CWE-918: Server-Side Request Forgery

#### urllib with User URL
**Pattern**: `urllib\.request\.urlopen\s*\([^)]*\+`
**Type**: regex
**Severity**: critical
**Languages**: [python]
- urllib with string concatenation
- CWE-918: Server-Side Request Forgery

#### httpx/aiohttp User URL
**Pattern**: `(httpx|aiohttp)\.(get|post)\s*\(\s*(request\.|user_|url_)`
**Type**: regex
**Severity**: critical
**Languages**: [python]
- httpx/aiohttp with user input
- CWE-918: Server-Side Request Forgery

### JavaScript SSRF

#### Fetch with User URL
**Pattern**: `fetch\s*\(\s*(req\.(body|query|params)|userUrl|url)`
**Type**: regex
**Severity**: critical
**Languages**: [javascript, typescript]
- fetch() with user-controlled URL
- CWE-918: Server-Side Request Forgery

#### Axios with User URL
**Pattern**: `axios\.(get|post|put|delete)\s*\(\s*(req\.(body|query|params)|userUrl)`
**Type**: regex
**Severity**: critical
**Languages**: [javascript, typescript]
- axios with user-controlled URL
- CWE-918: Server-Side Request Forgery

#### Got/Node-fetch User URL
**Pattern**: `(got|node-fetch)\s*\(\s*(req\.|user|url)`
**Type**: regex
**Severity**: critical
**Languages**: [javascript, typescript]
- HTTP client with user input
- CWE-918: Server-Side Request Forgery

### Java SSRF

#### HttpURLConnection User URL
**Pattern**: `new\s+URL\s*\(\s*(request\.getParameter|userUrl)`
**Type**: regex
**Severity**: critical
**Languages**: [java]
- URL from request parameter
- CWE-918: Server-Side Request Forgery

#### RestTemplate User URL
**Pattern**: `restTemplate\.(getForEntity|postForEntity|exchange)\s*\(\s*(request\.getParameter|url)`
**Type**: regex
**Severity**: critical
**Languages**: [java]
- RestTemplate with user URL
- CWE-918: Server-Side Request Forgery

### Go SSRF

#### http.Get with User URL
**Pattern**: `http\.(Get|Post)\s*\(\s*(r\.(URL|FormValue)|userUrl)`
**Type**: regex
**Severity**: critical
**Languages**: [go]
- Go http with user-controlled URL
- CWE-918: Server-Side Request Forgery

### Cloud Metadata Access

#### AWS Metadata IP
**Pattern**: `169\.254\.169\.254`
**Type**: regex
**Severity**: critical
**Languages**: [python, javascript, typescript, java, go]
- AWS metadata endpoint access
- CWE-918: SSRF to Cloud Metadata

#### GCP Metadata
**Pattern**: `metadata\.google\.internal`
**Type**: regex
**Severity**: critical
**Languages**: [python, javascript, typescript, java, go]
- GCP metadata endpoint
- CWE-918: SSRF to Cloud Metadata

### Dangerous URL Parameters

#### URL/Callback Parameters
**Pattern**: `(url|uri|callback|webhook|redirect|next)\s*=\s*(req\.(query|body|params)|request\.(args|form))`
**Type**: regex
**Severity**: high
**Languages**: [python, javascript, typescript]
- URL parameter from user input
- CWE-918: Server-Side Request Forgery

#### Image/File URL from Request
**Pattern**: `(image_url|avatar_url|file_url|download_url)\s*=\s*(req\.|request\.)`
**Type**: regex
**Severity**: high
**Languages**: [python, javascript, typescript]
- File/image URL from user input
- CWE-918: Server-Side Request Forgery
