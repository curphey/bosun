<!--
Copyright (c) 2025 Crash Override Inc. - https://crashoverride.com

SPDX-License-Identifier: GPL-3.0
-->

# Cryptographic Weakness Patterns

## Weak Hash Algorithms (CWE-327)

### Description
Using deprecated or weak cryptographic algorithms that can be broken or have known vulnerabilities.

### Dangerous Patterns

**MD5 for Security**
```python
# VULNERABLE - MD5 is cryptographically broken
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()
```

```javascript
// VULNERABLE
const crypto = require('crypto');
const hash = crypto.createHash('md5').update(password).digest('hex');
```

**SHA1 for Security**
```python
# VULNERABLE - SHA1 has collision attacks
import hashlib
signature = hashlib.sha1(data.encode()).hexdigest()
```

```java
// VULNERABLE
MessageDigest md = MessageDigest.getInstance("SHA-1");
byte[] hash = md.digest(password.getBytes());
```

**Weak Encryption (DES, 3DES, RC4)**
```python
# VULNERABLE - DES has 56-bit key
from Crypto.Cipher import DES
cipher = DES.new(key, DES.MODE_ECB)
```

```java
// VULNERABLE
Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
```

### Safe Patterns

**For Password Hashing**
```python
# SECURE - bcrypt
import bcrypt
password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())

# SECURE - Argon2
from argon2 import PasswordHasher
ph = PasswordHasher()
hash = ph.hash(password)
```

```javascript
// SECURE - bcrypt
const bcrypt = require('bcrypt');
const hash = await bcrypt.hash(password, 12);
```

**For General Hashing**
```python
# SECURE - SHA-256
import hashlib
hash = hashlib.sha256(data.encode()).hexdigest()

# SECURE - SHA-3
hash = hashlib.sha3_256(data.encode()).hexdigest()
```

**For Encryption**
```python
# SECURE - AES-256-GCM
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
key = AESGCM.generate_key(bit_length=256)
aesgcm = AESGCM(key)
ciphertext = aesgcm.encrypt(nonce, plaintext, associated_data)
```

---

## Hardcoded Cryptographic Keys (CWE-321)

### Description
Cryptographic keys embedded in source code can be extracted by attackers.

### Dangerous Patterns

```python
# VULNERABLE
SECRET_KEY = "my-super-secret-key-12345"
JWT_SECRET = "jwt-signing-secret"
AES_KEY = b"0123456789abcdef"
```

```javascript
// VULNERABLE
const jwtSecret = 'hardcoded-jwt-secret-key';
const encryptionKey = Buffer.from('0123456789abcdef');
```

```java
// VULNERABLE
private static final String SECRET_KEY = "hardcoded-secret";
private static final byte[] AES_KEY = "0123456789abcdef".getBytes();
```

### Safe Patterns

```python
# SECURE - from environment
import os
SECRET_KEY = os.environ.get('SECRET_KEY')

# SECURE - from key management service
from google.cloud import secretmanager
client = secretmanager.SecretManagerServiceClient()
secret = client.access_secret_version(name="projects/x/secrets/key/versions/latest")
```

```javascript
// SECURE
const jwtSecret = process.env.JWT_SECRET;

// SECURE - AWS Secrets Manager
const AWS = require('aws-sdk');
const secretsManager = new AWS.SecretsManager();
const secret = await secretsManager.getSecretValue({ SecretId: 'jwt-secret' }).promise();
```

---

## Insecure Random Number Generation (CWE-330)

### Description
Using non-cryptographic random number generators for security-sensitive operations.

### Dangerous Patterns

```python
# VULNERABLE - not cryptographically secure
import random
token = ''.join(random.choices('abcdef0123456789', k=32))
session_id = random.randint(0, 1000000)
```

```javascript
// VULNERABLE
const token = Math.random().toString(36).substring(2);
const sessionId = Math.floor(Math.random() * 1000000);
```

```java
// VULNERABLE
Random random = new Random();
int token = random.nextInt();
```

### Safe Patterns

```python
# SECURE
import secrets
token = secrets.token_hex(32)
session_id = secrets.token_urlsafe(32)
random_int = secrets.randbelow(1000000)
```

```javascript
// SECURE
const crypto = require('crypto');
const token = crypto.randomBytes(32).toString('hex');
const sessionId = crypto.randomUUID();
```

```java
// SECURE
SecureRandom random = new SecureRandom();
byte[] token = new byte[32];
random.nextBytes(token);
```

---

## ECB Mode Encryption (CWE-327)

### Description
ECB (Electronic Codebook) mode encrypts identical plaintext blocks to identical ciphertext blocks, leaking patterns.

### Dangerous Patterns

```python
# VULNERABLE - ECB mode
from Crypto.Cipher import AES
cipher = AES.new(key, AES.MODE_ECB)
ciphertext = cipher.encrypt(plaintext)
```

```java
// VULNERABLE
Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
```

### Safe Patterns

```python
# SECURE - GCM mode (authenticated encryption)
from Crypto.Cipher import AES
cipher = AES.new(key, AES.MODE_GCM)
ciphertext, tag = cipher.encrypt_and_digest(plaintext)

# SECURE - CBC mode with random IV
cipher = AES.new(key, AES.MODE_CBC, iv=os.urandom(16))
```

```java
// SECURE - GCM mode
Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
```

---

## Missing Encryption (CWE-311)

### Description
Sensitive data transmitted or stored without encryption.

### Dangerous Patterns

```python
# VULNERABLE - password sent over HTTP
requests.post('http://api.example.com/login', data={'password': password})

# VULNERABLE - storing sensitive data in plaintext
with open('users.txt', 'w') as f:
    f.write(f"{username}:{password}")
```

### Safe Patterns

```python
# SECURE - HTTPS only
requests.post('https://api.example.com/login', data={'password': password})

# SECURE - encrypt at rest
from cryptography.fernet import Fernet
key = Fernet.generate_key()
f = Fernet(key)
encrypted = f.encrypt(sensitive_data.encode())
```

---

## Insufficient Key Length (CWE-326)

### Dangerous Patterns

```python
# VULNERABLE - RSA key too short
from Crypto.PublicKey import RSA
key = RSA.generate(1024)  # Should be at least 2048
```

```java
// VULNERABLE
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(1024);  // Too short
```

### Safe Patterns

```python
# SECURE
key = RSA.generate(4096)  # Recommended
```

```java
// SECURE
keyGen.initialize(4096);
```

### Minimum Key Lengths

| Algorithm | Minimum | Recommended |
|-----------|---------|-------------|
| RSA | 2048 | 4096 |
| AES | 128 | 256 |
| ECDSA | 256 | 384 |
| HMAC | 256 | 512 |

---

## Detection Patterns

### Weak Hash Algorithms

#### MD5 Usage
**Pattern**: `(hashlib\.md5|createHash\s*\(\s*['\"]md5['\"]|MessageDigest\.getInstance\s*\(\s*['\"]MD5['\"])`
**Type**: regex
**Severity**: high
**Languages**: [python, javascript, typescript, java]
- MD5 hash algorithm (cryptographically broken)
- CWE-327: Use of Broken Crypto Algorithm

#### SHA1 Usage
**Pattern**: `(hashlib\.sha1|createHash\s*\(\s*['\"]sha1['\"]|MessageDigest\.getInstance\s*\(\s*['\"]SHA-?1['\"])`
**Type**: regex
**Severity**: medium
**Languages**: [python, javascript, typescript, java]
- SHA1 hash algorithm (collision attacks known)
- CWE-327: Use of Broken Crypto Algorithm

#### DES Encryption
**Pattern**: `(DES\.new|Cipher\.getInstance\s*\(\s*['\"]DES|from\s+Crypto\.Cipher\s+import\s+DES)`
**Type**: regex
**Severity**: high
**Languages**: [python, java]
- DES encryption (56-bit key, broken)
- CWE-327: Use of Broken Crypto Algorithm

#### RC4 Encryption
**Pattern**: `(ARC4\.new|RC4|Cipher\.getInstance\s*\(\s*['\"]RC4)`
**Type**: regex
**Severity**: high
**Languages**: [python, java]
- RC4 stream cipher (multiple vulnerabilities)
- CWE-327: Use of Broken Crypto Algorithm

### Hardcoded Cryptographic Keys

#### Hardcoded AES Key
**Pattern**: `(AES_KEY|aes_key|encryption_key)\s*=\s*['\"][^'\"]{16,}['\"]`
**Type**: regex
**Severity**: critical
**Languages**: [python, javascript, typescript, java]
- Hardcoded AES encryption key
- CWE-321: Hardcoded Crypto Key

#### Hardcoded JWT Secret
**Pattern**: `(JWT_SECRET|jwt_secret|jwtSecret)\s*[=:]\s*['\"][^'\"]{8,}['\"]`
**Type**: regex
**Severity**: critical
**Languages**: [python, javascript, typescript]
- Hardcoded JWT signing secret
- CWE-321: Hardcoded Crypto Key

### Insecure Random

#### Python random Module
**Pattern**: `random\.(choice|randint|random|choices|sample)\s*\(`
**Type**: regex
**Severity**: medium
**Languages**: [python]
- Python random module (not cryptographically secure)
- CWE-330: Insufficient Random Values

#### JavaScript Math.random
**Pattern**: `Math\.random\s*\(\)`
**Type**: regex
**Severity**: medium
**Languages**: [javascript, typescript]
- Math.random() (not cryptographically secure)
- CWE-330: Insufficient Random Values

#### Java Random Class
**Pattern**: `new\s+Random\s*\(\)|Random\(\)\.next`
**Type**: regex
**Severity**: medium
**Languages**: [java]
- java.util.Random (not cryptographically secure)
- CWE-330: Insufficient Random Values

### Weak Encryption Modes

#### ECB Mode
**Pattern**: `(MODE_ECB|AES/ECB|DES/ECB|Blowfish/ECB)`
**Type**: regex
**Severity**: high
**Languages**: [python, java]
- ECB encryption mode (pattern-preserving)
- CWE-327: Use of Broken Crypto Algorithm

### Insufficient Key Length

#### RSA 1024-bit Key
**Pattern**: `(RSA\.generate\s*\(\s*1024|initialize\s*\(\s*1024)`
**Type**: regex
**Severity**: high
**Languages**: [python, java]
- RSA key size below 2048 bits
- CWE-326: Inadequate Encryption Strength

#### Small AES Key
**Pattern**: `(generate_key\s*\(\s*bit_length\s*=\s*(64|96)|AESGCM\s*\(\s*[^)]{0,15}\))`
**Type**: regex
**Severity**: high
**Languages**: [python]
- AES key below 128 bits
- CWE-326: Inadequate Encryption Strength
