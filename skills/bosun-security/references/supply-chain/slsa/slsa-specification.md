# SLSA (Supply-chain Levels for Software Artifacts) - Technical Specification

## Overview

**SLSA** (pronounced "salsa") is a security framework that provides end-to-end supply chain integrity. It is a specification for describing and incrementally improving supply chain security posture.

**Current Version**: SLSA v1.0
**Website**: https://slsa.dev
**Maintained By**: OpenSSF (Open Source Security Foundation)

## Core Concepts

### What is SLSA?

SLSA is a set of incrementally adoptable security guidelines that:
- Establish a common vocabulary for supply chain security
- Provide actionable guidance for improving security posture
- Enable verification of software artifacts through provenance
- Support automated policy enforcement

### Key Components

1. **Provenance**: Attestation about how an artifact was produced
2. **Levels**: Four incrementally achieved security levels (0-4)
3. **Requirements**: Specific controls required at each level
4. **Verification**: Mechanisms to verify SLSA compliance

## SLSA Levels

### Level 0: No guarantees
- **Description**: No specific requirements
- **Security Posture**: No integrity or provenance guarantees
- **Use Case**: Initial state, legacy systems

### Level 1: Documentation of build process
**Requirements**:
- Build process must be fully documented
- Provenance must be generated describing how artifact was built
- Provenance must include:
  - Build platform
  - Top-level build command
  - Materials (dependencies)
  - Build outputs

**Security Benefits**:
- Enables auditability
- Provides basic transparency
- Supports incident response

**Example**: CI/CD system that generates build logs

### Level 2: Tamper resistance
**Requirements** (includes all Level 1):
- **Signed provenance**: Provenance must be cryptographically signed
- **Service-generated**: Provenance generated by build service, not user-controlled
- **Build service identity**: Build service must be identifiable

**Security Benefits**:
- Provenance cannot be tampered with after build
- Build source can be verified
- Enables automated verification

**Example**: GitHub Actions, Google Cloud Build with signed attestations

### Level 3: Hardened builds
**Requirements** (includes all Level 2):
- **Hardened platform**: Build platform must prevent secrets exfiltration
- **Isolated builds**: Builds must be isolated from each other
- **Non-falsifiable provenance**: Provenance must be unforgeable
- **Parameterless execution**: Build process must be deterministic

**Security Benefits**:
- Protection against insider threats
- Strong attestation of build process
- Reduced attack surface

**Example**: Hermetically sealed build environments, reproducible builds

### Level 4: Two-party review
**Requirements** (includes all Level 3):
- **Two-person review**: All changes must be reviewed by separate person
- **Explicit approval**: Changes must be explicitly approved
- **Retention policy**: Audit trail must be retained

**Security Benefits**:
- Highest integrity guarantees
- Prevention of single-point compromise
- Complete auditability

**Example**: Critical infrastructure, high-security projects

## SLSA Provenance Format

### Provenance Structure (v1.0)

```json
{
  "_type": "https://in-toto.io/Statement/v1",
  "subject": [
    {
      "name": "package-name",
      "digest": {
        "sha256": "abc123..."
      }
    }
  ],
  "predicateType": "https://slsa.dev/provenance/v1",
  "predicate": {
    "buildDefinition": {
      "buildType": "https://example.com/builder/v1",
      "externalParameters": {},
      "internalParameters": {},
      "resolvedDependencies": []
    },
    "runDetails": {
      "builder": {
        "id": "https://github.com/actions/runner"
      },
      "metadata": {
        "invocationId": "build-123",
        "startedOn": "2024-11-21T10:00:00Z",
        "finishedOn": "2024-11-21T10:15:00Z"
      },
      "byproducts": []
    }
  }
}
```

### Key Provenance Fields

#### Subject
- **name**: Artifact identifier
- **digest**: Cryptographic hash of artifact (typically SHA-256)

#### buildDefinition
- **buildType**: URI identifying build process type
- **externalParameters**: Inputs from user (source repo, commit, etc.)
- **internalParameters**: Build platform internal details
- **resolvedDependencies**: Complete dependency closure with hashes

#### runDetails
- **builder.id**: Identity of build platform
- **metadata**: Timing and invocation details
- **byproducts**: Additional outputs (logs, test results)

## Verification Process

### Verifying SLSA Provenance

1. **Obtain Provenance**
   - Download provenance attestation for artifact
   - Typically stored alongside artifact or in registry

2. **Verify Signature**
   - Check cryptographic signature on provenance
   - Verify signer identity (certificate chain)
   - Use cosign, sigstore, or similar tools

3. **Validate Contents**
   - Verify subject matches artifact
   - Check builder identity is trusted
   - Validate materials are complete
   - Check timestamps are reasonable

4. **Assess SLSA Level**
   - Evaluate against SLSA requirements
   - Check build platform capabilities
   - Verify isolation and hardening

### Example Verification (cosign)

```bash
# Verify signed provenance
cosign verify-attestation \
  --type slsaprovenance \
  --certificate-identity https://github.com/actions/runner \
  artifact.tar.gz

# Extract and inspect provenance
cosign verify-attestation \
  --type slsaprovenance \
  artifact.tar.gz | jq '.payload | @base64d | fromjson'
```

## Trusted Builders

### GitHub Actions
- **SLSA Level**: 3
- **Builder ID**: `https://github.com/actions/runner`
- **Provenance Format**: SLSA v0.2/v1.0
- **Signature**: Fulcio certificates via sigstore

### Google Cloud Build
- **SLSA Level**: 3
- **Builder ID**: `https://cloudbuild.googleapis.com`
- **Provenance Format**: SLSA v0.2
- **Signature**: Google-managed keys

### GitLab CI
- **SLSA Level**: 2
- **Builder ID**: `https://gitlab.com`
- **Provenance Format**: in-toto attestations

## Common Use Cases

### Package Registries
- **npm**: Native provenance support (SLSA Level 3)
- **PyPI**: Trusted publishers (SLSA Level 2)
- **Maven Central**: PGP signatures (SLSA Level 1)
- **Docker Hub**: Image signing via Notary (SLSA Level 2)

### Verifying Dependencies
```bash
# Check npm package provenance
npm audit signatures

# Verify Docker image
cosign verify \
  --certificate-identity https://github.com/actions/runner \
  docker.io/library/nginx:latest
```

### Organizational Policy
```yaml
# Example SLSA policy
slsa_requirements:
  minimum_level: 2
  trusted_builders:
    - https://github.com/actions/runner
    - https://cloudbuild.googleapis.com
  allowed_sources:
    - https://github.com/myorg/*
```

## Migration Path

### Phase 1: Level 0 → Level 1
1. Document build process
2. Generate provenance attestations
3. Store provenance with artifacts

### Phase 2: Level 1 → Level 2
1. Implement signing infrastructure
2. Use build service for provenance generation
3. Verify signatures in CI/CD

### Phase 3: Level 2 → Level 3
1. Harden build environment
2. Implement build isolation
3. Remove user control from provenance generation

### Phase 4: Level 3 → Level 4
1. Enforce two-party review
2. Implement approval workflows
3. Maintain comprehensive audit logs

## Ecosystem Integration

### Language Ecosystems

**npm (JavaScript)**
- Native provenance since 2023
- Automatic SLSA Level 3 for npm publish
- Verification: `npm audit signatures`

**PyPI (Python)**
- Trusted Publishers model
- SLSA Level 2 via GitHub OIDC
- Verification: `pip-audit`

**Go Modules**
- Checksum database (sum.golang.org)
- Module transparency
- Verification: Built into go toolchain

**Maven (Java)**
- PGP signature requirements
- Central repository validation
- Verification: Maven verify phase

## Best Practices

### For Software Producers

1. **Start with Level 1**
   - Generate provenance for all builds
   - Document build process completely
   - Store provenance with artifacts

2. **Progress to Level 2**
   - Use established build platforms (GitHub Actions, etc.)
   - Implement provenance signing
   - Automate verification in release process

3. **Aim for Level 3**
   - Use hardened build environments
   - Implement hermetic builds
   - Remove manual steps from build process

### For Software Consumers

1. **Verify Provenance**
   - Check provenance exists for dependencies
   - Verify signatures on provenance
   - Validate builder identity

2. **Assess SLSA Level**
   - Understand SLSA level of dependencies
   - Prioritize higher-level dependencies
   - Document gaps for risk assessment

3. **Enforce Policy**
   - Define minimum acceptable SLSA level
   - Allowlist trusted builders
   - Automate verification in CI/CD

## Tools and Libraries

### Verification Tools
- **cosign**: Container and artifact signing/verification
- **rekor-cli**: Transparency log verification
- **slsa-verifier**: Dedicated SLSA verification tool

### Generation Tools
- **slsa-github-generator**: GitHub Actions integration
- **slsa-provenance**: Language-agnostic generator
- **witness**: Attestation generation framework

## References

- **SLSA Specification**: https://slsa.dev/spec/v1.0/
- **Provenance Format**: https://slsa.dev/provenance/v1
- **GitHub Implementation**: https://github.blog/security/supply-chain-security/introducing-npm-package-provenance/
- **Google SLSA**: https://security.googleblog.com/2021/06/introducing-slsa-end-to-end-framework.html

## Glossary

**Artifact**: Output of a build process (binary, package, container image)
**Attestation**: Signed metadata about software artifact
**Builder**: Service or system that performs builds
**Hermetic**: Build that is isolated from network and external state
**Material**: Input to build process (source code, dependencies)
**Provenance**: Metadata describing how artifact was built
**Subject**: Artifact that provenance describes
**Transparency Log**: Append-only ledger of attestations (Rekor)
